---
title: "R_programming_module_1"
author: "Austen"
date: "8/13/2025"
output: pdf_document
---

```{r}
#Objects in R
#five 'atomic' classes of objects
#1. character
#2. numeric (same as float)
#3. integer
#4. complex
#5. logical

#vector, one of the most simple objects
#vectors can only contain one type of data, but LISTS can have different types of data (lists are represented as vectors)

#empty vectors can be made with vector(data_type, vector_length)
x <- vector('numeric', length = 10)

#c() makes vector objects

x <- c(.5, .6) ## numeric
x <- c(TRUE, FALSE) ## logical
x <- c(T, F) #logical
x <- c('a', 'b', 'c') #character
x <- 9:29 #integer
x <- c(1+0i, 2+4i) #complex


#change data types (coercion)
x <- 0:6
class(x)
as.numeric(x)
x
as.logical(x)
x
as.character(x)

#if coercion doesn't work, data will be na's


x <- list(1, 'a', TRUE, 1 + 4i)
x

#matrices are a type of vector, but the have an attribute called 'dimension'
#matrices are filled column-wise


m <- matrix(nrow = 2, ncol= 3)
m

dim(m) # gives the dimensions of the matrix
attributes(m)


#can make a matrix from a vector by assigning a dimension attribute to it
m <- 1:10 #make a simple vector
m

dim(m) <- c(2, 5)
m


#make matrix with column binding and row binding
x <- 1:3
y <- 10:12

cbind(x,y)
rbind(x,y)


#factors are vectors that represent categorical data (can be ordered or unordered)
#each element has a label
#make with factor(), each input is a character variable

x <- factor(c('yes', 'yes', 'no', 'yes'))
x #prints out the vector, and the 'levels'

#use levels argument if you want the levels to be in a particular order
x <- factor(c('yes','yes','no','yes'), levels = c('yes','no'))
x


#missing values: NA non-mathematical, NaN mathematical
#is.na()
#is.nan()

#All R objects can have names
#get name of objects with name(object)

```

```{r}
#reading data

#read.table() and read.csv() most common for reading in tablular data
##read.table() is most commonly usef for reading data

#read.table(file, header, sep, colClasses, nrows, comment.char, skip, stringsAsFactors)
#file - name of file or connection
#header - T/F indicates if file has a header line
#sep - string indicates how columns are separated
#colClasses - character vector; indicates each class of each column
#nrows - number of rows in the dataset
#comment.char - string for the comment character
#skip - number lines to skip from the beginning
#stringsAsFactors - (defaults to True) should character variables be coded as factors

#read.csv() is basically the same as read.table() except that sep default is ',' for .csv() and ' ' for .table(); and the header defaults to TRUE

#input the colClasses argument to save RAM when reading a table, otherwise R will try to figure out data types on its own




#readLines() for reading lines in a file

#source() is for reading R code files

#dget() also for reading in R code files

#load() read saved worspaces

#unserialize() read single R objects in binary form




```

```{r}
#Textual formats

#dump() and dput(), preserve metadata (sacrifice some readability), they are editable

#more compatible with version control

#Easier to fix errors and corruption

#not space-efficient

y <- data.frame(a = 1, b = 'a')
dput(y)

dput(y, file = 'y.R')

new.y <- dget('y.R')

new.y

#dump() like dget(), but dump() can be used on multiple R objects instead of just 1

x <- 'foo'
y <- data.frame(a=1, b='a')

#pass the NAMES of the objects to the dump() function
dump(c('x', 'y'), file = 'data.R')

#now objects can be removed, then recovered with the source() function
rm(x, y)

source('data.R')

y

x

```

```{r}
#Subsetting

#Three main operators: [], [[]], and $
#[] returns object as same class as original
#[[]] extract elements of a list or dataframe; extracts a single element that will not necessarily be the same class as the original
#$ extracts elements of list or dataframe by name


#get subsets with indexing
x <- c('a', 'b', 'c', 'c', 'd', 'a')
x[1]
x[2]
x[1:4]

#use logical indexing
x[x > 'a']


#make another variable that stores the T/F for each element for a logical statement
u <- x > 'a'
u

#then use that variable to subset the original list
x[u]

```

```{r}
#subset lists
x <- list(foo=1:4, bar=.6, baz = 'yo')

#returns a list called 'foo' which contains a sequence (because x is a list)
x[1]


#returns just the sequence without an associated name and of different class from the original list
x[[1]]

x$bar

x[['bar']]

x['bar']

#want multiple elements from the list, need to use []
x[c(1, 3)]

```
```{r}
#Subset matrices
x <- matrix(1:6, 2, 3)
x[1, 2]

x[2, 1]

x[1, ]

x[, 2]

#to preserve dimension of the matrix use drop argument
x[1, 2]
x[1, 2, drop=FALSE]

```

```{r}
#remove NA values
#create a logical vector that tells you where the NA's are in the dataset

#remove by subsetting
x <- c(1, 2, NA, 4, NA, 5)
bad <- is.na(x) #a logical vector
x[!bad]


#multiple things and want to take the subset with no missing values
x <- c(1, 2, NA, 4, NA, 5)
y <- c('a', 'b', NA, 'd', NA, 'f')
good <- complete.cases(x, y) #returns logical vector; TRUE where element in both lists is non-empty
good

x[good]
y[good]


#can use complete.cases(dataframe); returns logical that says which rows of the df have no NA's at all
#df[logical, ] subsets the dataframe to all the rows that do not contain a single NA

```

```{r}
#get the dataset from the csv file
setwd('/Users/austenjack/Desktop/Coursera')

quiz1 <- read.csv('hw1_data.csv')

```

```{r}
colnames(quiz1)

quiz1[1:2,]

nrow(quiz1)

tail(quiz1, n=2)

ozone47 <- quiz1[47,]$Ozone
ozone47

sum(is.na(quiz1$Ozone))

mean(quiz1$Ozone, na.rm = TRUE)

sub <- quiz1[(quiz1$Ozone > 31) & (quiz1$Temp > 90),]
mean(sub$Solar.R, na.rm=TRUE)

mean(quiz1[quiz1$Month == 6,]$Temp, na.rm=TRUE)

max(quiz1[quiz1$Month ==5, ]$Ozone, na.rm=TRUE)
```















